{% extends "base.html" %}

{% block title %}Live Logs - Sentinel Logger{% endblock %}

{% block extra_css %}
<style>
/* Live Stream Container */
.stream-container {
    display: flex;
    flex-direction: column;
    height: calc(100vh - 180px);
}

/* Connection Panel */
.connection-panel {
    background: var(--bg-secondary, #f8fafc);
    border: 1px solid var(--border-color, #e2e8f0);
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
}

.connection-panel .form-label {
    font-size: 0.85rem;
    font-weight: 500;
}

/* Stream Toolbar */
.stream-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    background: var(--bg-secondary, #f8fafc);
    border: 1px solid var(--border-color, #e2e8f0);
    border-radius: 8px 8px 0 0;
}

.stream-status {
    display: flex;
    align-items: center;
    gap: 8px;
}

.status-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #6b7280;
}

.status-indicator.connected {
    background: #10b981;
    animation: pulse 2s infinite;
}

.status-indicator.connecting {
    background: #f59e0b;
    animation: pulse 0.5s infinite;
}

.status-indicator.error {
    background: #ef4444;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.stream-controls {
    display: flex;
    gap: 8px;
}

.stream-btn {
    padding: 6px 12px;
    border: 1px solid var(--border-color, #e2e8f0);
    background: var(--bg-primary, white);
    border-radius: 6px;
    font-size: 0.85rem;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
}

.stream-btn:hover {
    background: var(--bg-tertiary, #f1f5f9);
}

.stream-btn.active {
    background: #3b82f6;
    border-color: #3b82f6;
    color: white;
}

.stream-btn.danger {
    color: #ef4444;
    border-color: #ef4444;
}

.stream-btn.danger:hover {
    background: #ef4444;
    color: white;
}

/* Log Output */
.log-output {
    flex: 1;
    background: #0f172a;
    border: 1px solid var(--border-color, #e2e8f0);
    border-top: none;
    border-radius: 0 0 8px 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.log-output-inner {
    flex: 1;
    overflow-y: auto;
    padding: 12px;
    font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
    font-size: 13px;
    line-height: 1.5;
}

/* Log Lines */
.log-line {
    padding: 2px 8px;
    margin: 1px 0;
    border-radius: 3px;
    color: #e2e8f0;
    white-space: pre-wrap;
    word-break: break-all;
}

.log-line:hover {
    background: rgba(255, 255, 255, 0.05);
}

.log-line.error {
    background: rgba(239, 68, 68, 0.2);
    border-left: 3px solid #ef4444;
}

.log-line.warning {
    background: rgba(245, 158, 11, 0.2);
    border-left: 3px solid #f59e0b;
}

.log-line.info {
    color: #93c5fd;
}

.log-line.debug {
    color: #6b7280;
}

.log-line .timestamp {
    color: #64748b;
    margin-right: 8px;
}

.log-line .severity {
    font-weight: 600;
    margin-right: 8px;
}

.log-line .severity.error { color: #f87171; }
.log-line .severity.warning { color: #fbbf24; }
.log-line .severity.info { color: #60a5fa; }
.log-line .severity.debug { color: #9ca3af; }

/* Search in stream */
.stream-search {
    padding: 8px 12px;
    background: #1e293b;
    border-top: 1px solid #334155;
    display: flex;
    align-items: center;
    gap: 8px;
}

.stream-search input {
    flex: 1;
    padding: 6px 12px;
    border: 1px solid #334155;
    background: #0f172a;
    border-radius: 4px;
    color: #e2e8f0;
    font-size: 0.85rem;
}

.stream-search input:focus {
    outline: none;
    border-color: #3b82f6;
}

.stream-search .match-count {
    color: #64748b;
    font-size: 0.85rem;
}

/* Stats Bar */
.stream-stats {
    display: flex;
    gap: 16px;
    padding: 8px 12px;
    background: #1e293b;
    border-top: 1px solid #334155;
    font-size: 0.8rem;
    color: #94a3b8;
}

.stream-stats .stat {
    display: flex;
    align-items: center;
    gap: 4px;
}

.stream-stats .stat.errors .value { color: #f87171; }
.stream-stats .stat.warnings .value { color: #fbbf24; }

/* Paused overlay */
.paused-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 0.9rem;
    display: none;
}

.paused-overlay.visible {
    display: block;
}

/* Command input */
#sshCommand {
    font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
    font-size: 0.9rem;
}

#commandPreset {
    font-size: 0.85rem;
}

/* Source tabs */
.source-tabs {
    display: flex;
    gap: 4px;
    margin-bottom: 16px;
}

.source-tab {
    padding: 10px 20px;
    border: 1px solid var(--border-color, #e2e8f0);
    background: var(--bg-primary, white);
    border-radius: 8px 8px 0 0;
    cursor: pointer;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.source-tab:hover {
    background: var(--bg-tertiary, #f1f5f9);
}

.source-tab.active {
    background: var(--bg-secondary, #f8fafc);
    border-bottom-color: var(--bg-secondary, #f8fafc);
    font-weight: 500;
}

/* Filter chips */
.filter-chips {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
}

.filter-chip {
    padding: 4px 10px;
    background: var(--bg-tertiary, #e2e8f0);
    border-radius: 16px;
    font-size: 0.8rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 4px;
}

.filter-chip:hover {
    background: var(--border-color, #cbd5e1);
}

.filter-chip.active {
    background: #3b82f6;
    color: white;
}

.filter-separator {
    color: var(--border-color, #cbd5e1);
    margin: 0 8px;
}

.service-filter {
    width: auto;
    min-width: 150px;
    max-width: 200px;
    font-size: 0.8rem;
    padding: 4px 8px;
    height: auto;
    border-radius: 16px;
    background: var(--bg-tertiary, #e2e8f0);
    border: none;
}

.service-filter:focus {
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
}

.service-count {
    font-size: 0.75rem;
    margin-left: 4px;
}
</style>
{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-3">
    <div>
        <h1 class="h4 mb-1">
            <i class="bi bi-broadcast text-success me-2"></i>Live Log Stream
        </h1>
        <p class="text-muted mb-0" style="font-size: 0.9rem;">Watch logs in real-time from camera via SSH or Serial</p>
    </div>
</div>

<!-- Camera Connection Panel -->
<div class="connection-panel" id="cameraPanel">
    <!-- Transport Selection -->
    <div class="row mb-3">
        <div class="col-12">
            <div class="btn-group" role="group">
                <input type="radio" class="btn-check" name="transport" id="transportSSH" value="ssh" checked onchange="switchTransport('ssh')">
                <label class="btn btn-outline-primary" for="transportSSH">
                    <i class="bi bi-wifi me-1"></i>SSH (WiFi)
                </label>
                <input type="radio" class="btn-check" name="transport" id="transportSerial" value="serial" onchange="switchTransport('serial')">
                <label class="btn btn-outline-primary" for="transportSerial">
                    <i class="bi bi-usb-symbol me-1"></i>Serial (USB)
                </label>
            </div>
        </div>
    </div>

    <!-- SSH Settings -->
    <div class="row g-3 align-items-end" id="sshSettings">
        <div class="col-md-2">
            <label class="form-label">Camera IP</label>
            <input type="text" class="form-control" id="cameraHost" value="192.168.50.1" placeholder="192.168.50.1">
        </div>
        <div class="col-md-1">
            <label class="form-label">Port</label>
            <input type="number" class="form-control" id="cameraPort" value="22">
        </div>
        <div class="col-md-1">
            <label class="form-label">Username</label>
            <input type="text" class="form-control" id="cameraUser" value="root">
        </div>
        <div class="col-md-2">
            <label class="form-label">Password</label>
            <input type="password" class="form-control" id="cameraPass" value="">
        </div>
        <div class="col-md-5">
            <label class="form-label">Command</label>
            <div class="input-group">
                <select class="form-select" id="commandPreset" onchange="applyCommandPreset()" style="max-width: 140px;">
                    <optgroup label="Presets">
                        <option value="">Custom...</option>
                        <option value="tail -n 100 -f /var/log/messages" selected>System Log</option>
                        <option value="journalctl -f">journalctl -f</option>
                        <option value="journalctl -f -u nexagons_one">nexagons_one</option>
                        <option value="dmesg -w">dmesg -w</option>
                        <option value="top -b -d 2">top (2s)</option>
                        <option value="vmstat 2">vmstat</option>
                        <option value="tail -f /tmp/video.log">Video Log</option>
                        <option value="tail -f /tmp/audio.log">Audio Log</option>
                    </optgroup>
                    <optgroup label="History" id="commandHistory">
                    </optgroup>
                </select>
                <input type="text" class="form-control" id="sshCommand" value="tail -n 100 -f /var/log/messages" placeholder="tail -f /var/log/messages">
                <button class="btn btn-outline-secondary" type="button" onclick="clearCommandHistory()" title="Clear history">
                    <i class="bi bi-clock-history"></i>
                </button>
            </div>
        </div>
        <div class="col-md-1">
            <button class="btn btn-outline-secondary w-100" onclick="testConnection()" id="btnTest" title="Test SSH connection">
                <i class="bi bi-plug"></i>
            </button>
        </div>
    </div>

    <!-- Serial Settings (hidden by default) -->
    <div class="row g-3 align-items-end d-none" id="serialSettings">
        <div class="col-md-2">
            <label class="form-label">Mode</label>
            <select class="form-select" id="serialMode" onchange="switchSerialMode()">
                <option value="soc" selected>SOC (Login)</option>
                <option value="mcu">MCU (Read-only)</option>
            </select>
        </div>
        <div class="col-md-3">
            <label class="form-label">Serial Port</label>
            <div class="input-group">
                <select class="form-select" id="serialPort">
                    <option value="">Select port...</option>
                </select>
                <button class="btn btn-outline-secondary" onclick="scanSerialPorts()" id="btnScan" title="Scan ports">
                    <i class="bi bi-arrow-repeat"></i>
                </button>
            </div>
        </div>
        <div class="col-md-1">
            <label class="form-label">Baud</label>
            <select class="form-select" id="serialBaud">
                <option value="115200" selected>115200</option>
                <option value="9600">9600</option>
                <option value="57600">57600</option>
                <option value="921600">921600</option>
            </select>
        </div>
        <div class="col-md-5" id="socCommandDiv">
            <label class="form-label">Command</label>
            <input type="text" class="form-control" id="serialCommand" value="tail -n 100 -f /var/log/messages" placeholder="tail -f /var/log/messages">
        </div>
        <div class="col-md-5 d-none" id="mcuInfoDiv">
            <label class="form-label">Info</label>
            <div class="form-control bg-light text-muted" style="height: 38px; line-height: 24px;">
                <i class="bi bi-info-circle me-1"></i>MCU streams raw data (read-only, no commands)
            </div>
        </div>
        <div class="col-md-1">
            <button class="btn btn-outline-secondary w-100" onclick="testSerialConnection()" id="btnTestSerial" title="Test serial">
                <i class="bi bi-plug"></i>
            </button>
        </div>
    </div>

    <!-- Connection status alert -->
    <div id="connectionAlert" class="alert mt-3 mb-0 d-none" role="alert"></div>
</div>

<!-- Stream Container -->
<div class="stream-container">
    <!-- Toolbar -->
    <div class="stream-toolbar">
        <div class="stream-status">
            <span class="status-indicator" id="statusIndicator"></span>
            <span id="statusText">Disconnected</span>
        </div>

        <div class="filter-chips">
            <button class="filter-chip active" data-filter="all" onclick="setFilter('all')">All</button>
            <button class="filter-chip" data-filter="error" onclick="setFilter('error')">
                <i class="bi bi-x-circle"></i>Errors
            </button>
            <button class="filter-chip" data-filter="warning" onclick="setFilter('warning')">
                <i class="bi bi-exclamation-triangle"></i>Warnings
            </button>
            <button class="filter-chip" data-filter="info" onclick="setFilter('info')">
                <i class="bi bi-info-circle"></i>Info
            </button>
            <span class="filter-separator">|</span>
            <select class="form-select form-select-sm service-filter" id="processFilter" onchange="setProcessFilter(this.value)">
                <option value="">All Processes</option>
            </select>
            <span class="service-count text-muted" id="processCount">(0 processes)</span>
        </div>

        <div class="stream-controls">
            <button class="stream-btn" id="btnAutoscroll" onclick="toggleAutoscroll()" title="Auto-scroll">
                <i class="bi bi-arrow-down-circle"></i>
                <span>Auto-scroll</span>
            </button>
            <button class="stream-btn" id="btnPause" onclick="togglePause()" title="Pause/Resume">
                <i class="bi bi-pause-fill"></i>
            </button>
            <button class="stream-btn" onclick="clearLogs()" title="Clear">
                <i class="bi bi-trash"></i>
            </button>
            <button class="stream-btn" onclick="copyAllLogs()" title="Copy All">
                <i class="bi bi-clipboard"></i>
            </button>
            <button class="stream-btn active" id="btnConnect">
                <i class="bi bi-play-fill"></i>
                <span>Connect</span>
            </button>
        </div>
    </div>

    <!-- Log Output -->
    <div class="log-output" style="position: relative;">
        <div class="log-output-inner" id="logOutput">
            <div class="text-center text-muted py-5">
                <i class="bi bi-broadcast" style="font-size: 3rem; opacity: 0.3;"></i>
                <p class="mt-3">Click <strong>Connect</strong> to start streaming logs</p>
            </div>
        </div>
        <div class="paused-overlay" id="pausedOverlay">
            <i class="bi bi-pause-circle me-2"></i>Paused - Click to resume
        </div>

        <!-- Search -->
        <div class="stream-search">
            <i class="bi bi-search" style="color: #64748b;"></i>
            <input type="text" id="streamSearch" placeholder="Filter logs... (Ctrl+F)" onkeyup="filterLogs(this.value)">
            <span class="match-count" id="matchCount"></span>
        </div>

        <!-- Stats -->
        <div class="stream-stats">
            <div class="stat">
                <i class="bi bi-hash"></i>
                <span>Lines:</span>
                <span class="value" id="statLines">0</span>
            </div>
            <div class="stat errors">
                <i class="bi bi-x-circle"></i>
                <span>Errors:</span>
                <span class="value" id="statErrors">0</span>
            </div>
            <div class="stat warnings">
                <i class="bi bi-exclamation-triangle"></i>
                <span>Warnings:</span>
                <span class="value" id="statWarnings">0</span>
            </div>
            <div class="stat">
                <i class="bi bi-clock"></i>
                <span>Duration:</span>
                <span class="value" id="statDuration">0:00</span>
            </div>
        </div>
    </div>
</div>

<!-- Copy Toast -->
<div class="copy-toast" id="copyToast" style="position: fixed; bottom: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; display: none; z-index: 9999;">
    <i class="bi bi-check-circle me-2"></i><span id="copyToastText">Copied!</span>
</div>
{% endblock %}

{% block extra_js %}
<script>
// ============================================
// Live Stream State
// ============================================
let currentTransport = 'ssh';  // 'ssh' or 'serial'

const streamState = {
    connected: false,
    paused: false,
    autoscroll: true,
    filter: 'all',
    processFilter: '',  // Filter by process name
    searchTerm: '',
    eventSource: null,
    lines: [],
    processes: new Set(),  // Track detected processes
    stats: {
        total: 0,
        errors: 0,
        warnings: 0,
        startTime: null
    }
};

// ============================================
// Test Connection
// ============================================
function testConnection() {
    const host = document.getElementById('cameraHost').value;
    const port = document.getElementById('cameraPort').value;
    const user = document.getElementById('cameraUser').value;
    const pass = document.getElementById('cameraPass').value;
    const btn = document.getElementById('btnTest');
    const alert = document.getElementById('connectionAlert');

    // Show loading state
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';

    fetch('/api/stream/test-connection', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ host, port: parseInt(port), username: user, password: pass })
    })
    .then(r => r.json())
    .then(data => {
        alert.classList.remove('d-none', 'alert-success', 'alert-danger');
        if (data.success) {
            alert.classList.add('alert-success');
            alert.innerHTML = `<i class="bi bi-check-circle me-2"></i>${data.message}`;
        } else {
            alert.classList.add('alert-danger');
            alert.innerHTML = `<i class="bi bi-x-circle me-2"></i>${data.message}`;
        }
        // Auto-hide after 5 seconds
        setTimeout(() => alert.classList.add('d-none'), 5000);
    })
    .catch(err => {
        alert.classList.remove('d-none', 'alert-success');
        alert.classList.add('alert-danger');
        alert.innerHTML = `<i class="bi bi-x-circle me-2"></i>Failed to test connection: ${err.message}`;
    })
    .finally(() => {
        btn.disabled = false;
        btn.innerHTML = '<i class="bi bi-plug"></i>';
    });
}

// ============================================
// Command History Management
// ============================================
const HISTORY_KEY = 'sentinel_command_history';
const MAX_HISTORY = 20;

function getCommandHistory() {
    try {
        return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
    } catch {
        return [];
    }
}

function saveCommandToHistory(command) {
    if (!command || command.trim() === '') return;

    let history = getCommandHistory();

    // Remove if already exists (will re-add at top)
    history = history.filter(h => h.command !== command);

    // Add to beginning with timestamp
    history.unshift({
        command: command,
        timestamp: Date.now(),
        label: command.length > 30 ? command.substring(0, 30) + '...' : command
    });

    // Keep only last MAX_HISTORY items
    history = history.slice(0, MAX_HISTORY);

    localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    renderCommandHistory();
}

function renderCommandHistory() {
    const historyGroup = document.getElementById('commandHistory');
    if (!historyGroup) return;

    const history = getCommandHistory();
    historyGroup.innerHTML = '';

    if (history.length === 0) {
        historyGroup.innerHTML = '<option disabled>No history yet</option>';
        return;
    }

    history.forEach((item, index) => {
        const option = document.createElement('option');
        option.value = item.command;
        const time = new Date(item.timestamp).toLocaleTimeString();
        option.textContent = `${item.label}`;
        option.title = item.command; // Full command on hover
        historyGroup.appendChild(option);
    });
}

function clearCommandHistory() {
    if (confirm('Clear command history?')) {
        localStorage.removeItem(HISTORY_KEY);
        renderCommandHistory();
    }
}

// ============================================
// Connection Management
// ============================================
function toggleConnection() {
    console.log('toggleConnection() called, connected:', streamState.connected);
    if (streamState.connected) {
        disconnect();
    } else {
        connect();
    }
}

function connect() {
    console.log('connect() called, currentTransport:', currentTransport);
    if (currentTransport === 'serial') {
        console.log('Calling connectSerial()');
        connectSerial();
    } else {
        console.log('Calling connectCamera()');
        connectCamera();
    }
}

function applyCommandPreset() {
    const preset = document.getElementById('commandPreset').value;
    if (preset) {
        document.getElementById('sshCommand').value = preset;
    }
}

function connectCamera() {
    console.log('connectCamera() started');
    const host = document.getElementById('cameraHost').value;
    const port = document.getElementById('cameraPort').value;
    const user = document.getElementById('cameraUser').value;
    const pass = document.getElementById('cameraPass').value;
    const command = document.getElementById('sshCommand').value;
    const alert = document.getElementById('connectionAlert');
    console.log('SSH params:', { host, port, user, command });

    // Hide any previous alerts
    alert.classList.add('d-none');

    setStatus('connecting', 'Connecting...');

    const url = `/api/stream/camera?host=${encodeURIComponent(host)}&port=${port}&username=${encodeURIComponent(user)}&password=${encodeURIComponent(pass)}&command=${encodeURIComponent(command)}`;

    streamState.eventSource = new EventSource(url);
    streamState.currentCommand = command;

    streamState.eventSource.onopen = function() {
        setStatus('connected', `Connected to ${host}`);
        streamState.connected = true;
        streamState.stats.startTime = Date.now();
        updateConnectButton(true);
        clearLogOutput();
    };

    streamState.commandSaved = false; // Track if we saved this command

    streamState.eventSource.onmessage = function(event) {
        try {
            const data = JSON.parse(event.data);

            if (data.type === 'connected') {
                setStatus('connected', `${host}: ${data.command || 'streaming'}`);
                // Hide alert on successful connection
                alert.classList.add('d-none');
            } else if (data.type === 'log') {
                // Save command to history on first successful output
                if (!streamState.commandSaved && streamState.currentCommand) {
                    saveCommandToHistory(streamState.currentCommand);
                    streamState.commandSaved = true;
                }
                addLogLine(data.content);
            } else if (data.type === 'error') {
                setStatus('error', 'Connection Error');
                // Show detailed error in alert
                alert.classList.remove('d-none', 'alert-success');
                alert.classList.add('alert-danger');
                alert.innerHTML = `<i class="bi bi-x-circle me-2"></i><strong>Error:</strong> ${data.message}`;
                addLogLine(`[ERROR] ${data.message}`, 'error');
                // Auto disconnect on error
                disconnect();
            } else if (data.type === 'disconnected') {
                setStatus('disconnected', 'Disconnected');
                streamState.connected = false;
                updateConnectButton(false);
            }
        } catch (e) {
            console.error('Parse error:', e);
        }
    };

    streamState.eventSource.onerror = function(e) {
        const host = document.getElementById('cameraHost').value;
        const alert = document.getElementById('connectionAlert');

        setStatus('error', 'Connection failed');
        streamState.connected = false;
        updateConnectButton(false);

        // Show helpful error message
        alert.classList.remove('d-none', 'alert-success');
        alert.classList.add('alert-danger');
        alert.innerHTML = `<i class="bi bi-x-circle me-2"></i><strong>Connection failed to ${host}</strong><br>
            <small>Possible causes: Camera not connected, SSH not enabled, wrong IP/port, or network issue.
            Click the <i class="bi bi-plug"></i> button to test the connection.</small>`;
    };
}

function disconnect() {
    if (streamState.eventSource) {
        streamState.eventSource.close();
        streamState.eventSource = null;
    }

    streamState.connected = false;
    setStatus('disconnected', 'Disconnected');
    updateConnectButton(false);
}

// ============================================
// UI Helpers
// ============================================
function setStatus(status, text) {
    const indicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');

    indicator.className = 'status-indicator ' + status;
    statusText.textContent = text;
}

function updateConnectButton(connected) {
    const btn = document.getElementById('btnConnect');
    if (connected) {
        btn.innerHTML = '<i class="bi bi-stop-fill"></i><span>Disconnect</span>';
        btn.classList.add('danger');
    } else {
        btn.innerHTML = '<i class="bi bi-play-fill"></i><span>Connect</span>';
        btn.classList.remove('danger');
    }
}

function clearLogOutput() {
    document.getElementById('logOutput').innerHTML = '';
    streamState.lines = [];
    streamState.processes.clear();
    streamState.processFilter = '';
    streamState.stats = { total: 0, errors: 0, warnings: 0, startTime: Date.now() };
    updateStats();
    updateProcessDropdown();
}

function formatEntry(entry) {
    const ts = entry.timestamp ? new Date(entry.timestamp).toLocaleTimeString() : '';
    return `${ts} [${entry.severity || 'INFO'}] ${entry.raw_content}`;
}

function getSeverityClass(severity) {
    if (!severity) return '';
    const s = severity.toLowerCase();
    if (s === 'error' || s === 'critical') return 'error';
    if (s === 'warning' || s === 'warn') return 'warning';
    if (s === 'info') return 'info';
    if (s === 'debug') return 'debug';
    return '';
}

// ============================================
// Process Detection
// ============================================
function detectProcess(content) {
    // Log format: "Feb  4 15:35:13.912455 [info] logstore[620]: message"
    // Pattern: "<Month> <day> <time> [level] processname[pid]: message"

    const patterns = [
        // Nexar camera format: "Feb  4 15:35:13.912455 [info] processname[pid]:"
        /^\w+\s+\d+\s+[\d:.]+\s+\[\w+\]\s+([a-zA-Z_][\w_.-]*)\[\d+\]:/,
        // Alternative: "Feb  4 15:35:13 processname[pid]:"
        /^\w+\s+\d+\s+[\d:.]+\s+([a-zA-Z_][\w_.-]*)\[\d+\]:/,
        // Simple format: "processname[pid]: message"
        /([a-zA-Z_][\w_.-]*)\[\d+\]:/,
    ];

    for (const pattern of patterns) {
        const match = content.match(pattern);
        if (match && match[1]) {
            const process = match[1];
            // Filter out noise
            if (process.length > 1 &&
                !['info', 'debug', 'warn', 'error', 'fatal'].includes(process.toLowerCase())) {
                return process;
            }
        }
    }
    return null;
}

function updateProcessDropdown() {
    const select = document.getElementById('processFilter');
    const countEl = document.getElementById('processCount');
    if (!select) return;

    const currentValue = select.value;
    select.innerHTML = '<option value="">All Processes</option>';

    // Sort processes alphabetically
    const sortedProcesses = Array.from(streamState.processes).sort();

    sortedProcesses.forEach(process => {
        const option = document.createElement('option');
        option.value = process;
        option.textContent = process;
        select.appendChild(option);
    });

    // Restore selection if still valid
    if (currentValue && streamState.processes.has(currentValue)) {
        select.value = currentValue;
    }

    if (countEl) {
        countEl.textContent = `(${sortedProcesses.length} processes)`;
    }
}

function setProcessFilter(process) {
    streamState.processFilter = process;
    rerenderLogs();
}

// ============================================
// Log Line Management
// ============================================
function addLogLine(content, severityClass = '') {
    if (streamState.paused) return;

    // Detect process from content
    const process = detectProcess(content);
    if (process) {
        const prevSize = streamState.processes.size;
        streamState.processes.add(process);
        // Update dropdown if new process detected
        if (streamState.processes.size > prevSize) {
            updateProcessDropdown();
        }
    }

    // Detect severity from content
    if (!severityClass) {
        const contentLower = content.toLowerCase();
        if (contentLower.includes('error') || contentLower.includes('fail') || contentLower.includes('fatal')) {
            severityClass = 'error';
        } else if (contentLower.includes('warn')) {
            severityClass = 'warning';
        } else if (contentLower.includes('info')) {
            severityClass = 'info';
        } else if (contentLower.includes('debug')) {
            severityClass = 'debug';
        }
    }

    // Update stats
    streamState.stats.total++;
    if (severityClass === 'error') streamState.stats.errors++;
    if (severityClass === 'warning') streamState.stats.warnings++;
    updateStats();

    // Store line with process
    streamState.lines.push({ content, severityClass, process });

    // Check severity filter
    if (streamState.filter !== 'all' && severityClass !== streamState.filter) {
        return; // Don't display if filtered out
    }

    // Check process filter
    if (streamState.processFilter && process !== streamState.processFilter) {
        return; // Don't display if process doesn't match
    }

    // Check search
    if (streamState.searchTerm && !content.toLowerCase().includes(streamState.searchTerm.toLowerCase())) {
        return;
    }

    // Create element
    const line = document.createElement('div');
    line.className = 'log-line ' + severityClass;
    line.textContent = content;
    if (process) {
        line.dataset.process = process;
    }

    const output = document.getElementById('logOutput');
    output.appendChild(line);

    // Auto-scroll
    if (streamState.autoscroll) {
        output.scrollTop = output.scrollHeight;
    }

    // Limit lines in DOM (keep last 2000)
    while (output.children.length > 2000) {
        output.removeChild(output.firstChild);
    }
}

function updateStats() {
    document.getElementById('statLines').textContent = streamState.stats.total;
    document.getElementById('statErrors').textContent = streamState.stats.errors;
    document.getElementById('statWarnings').textContent = streamState.stats.warnings;

    // Duration
    if (streamState.stats.startTime) {
        const seconds = Math.floor((Date.now() - streamState.stats.startTime) / 1000);
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        document.getElementById('statDuration').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }
}

// Update duration every second
setInterval(() => {
    if (streamState.connected) updateStats();
}, 1000);

// ============================================
// Controls
// ============================================
function togglePause() {
    streamState.paused = !streamState.paused;
    const btn = document.getElementById('btnPause');
    const overlay = document.getElementById('pausedOverlay');

    if (streamState.paused) {
        btn.innerHTML = '<i class="bi bi-play-fill"></i>';
        btn.classList.add('active');
        overlay.classList.add('visible');
    } else {
        btn.innerHTML = '<i class="bi bi-pause-fill"></i>';
        btn.classList.remove('active');
        overlay.classList.remove('visible');
    }
}

function toggleAutoscroll() {
    streamState.autoscroll = !streamState.autoscroll;
    const btn = document.getElementById('btnAutoscroll');
    btn.classList.toggle('active', streamState.autoscroll);
}

function setFilter(filter) {
    streamState.filter = filter;

    document.querySelectorAll('.filter-chip').forEach(chip => {
        chip.classList.toggle('active', chip.dataset.filter === filter);
    });

    // Re-render visible logs
    rerenderLogs();
}

function filterLogs(term) {
    streamState.searchTerm = term;
    rerenderLogs();
}

function rerenderLogs() {
    const output = document.getElementById('logOutput');
    output.innerHTML = '';

    let matchCount = 0;
    streamState.lines.forEach(({ content, severityClass, process }) => {
        // Check severity filter
        if (streamState.filter !== 'all' && severityClass !== streamState.filter) {
            return;
        }

        // Check process filter
        if (streamState.processFilter && process !== streamState.processFilter) {
            return;
        }

        // Check search
        if (streamState.searchTerm && !content.toLowerCase().includes(streamState.searchTerm.toLowerCase())) {
            return;
        }

        matchCount++;
        const line = document.createElement('div');
        line.className = 'log-line ' + severityClass;
        if (process) {
            line.dataset.process = process;
        }

        // Highlight search term
        if (streamState.searchTerm) {
            const regex = new RegExp(`(${escapeRegex(streamState.searchTerm)})`, 'gi');
            line.innerHTML = content.replace(regex, '<mark style="background:#fef08a;color:#000;">$1</mark>');
        } else {
            line.textContent = content;
        }

        output.appendChild(line);
    });

    document.getElementById('matchCount').textContent = streamState.searchTerm ? `${matchCount} matches` : '';

    if (streamState.autoscroll) {
        output.scrollTop = output.scrollHeight;
    }
}

function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function clearLogs() {
    clearLogOutput();
}

function copyAllLogs() {
    const text = streamState.lines.map(l => l.content).join('\n');
    navigator.clipboard.writeText(text).then(() => {
        const toast = document.getElementById('copyToast');
        document.getElementById('copyToastText').textContent = `Copied ${streamState.lines.length} lines!`;
        toast.style.display = 'block';
        setTimeout(() => toast.style.display = 'none', 2000);
    });
}

// ============================================
// Keyboard Shortcuts
// ============================================
document.addEventListener('keydown', function(e) {
    // Ctrl+F to focus search
    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        document.getElementById('streamSearch').focus();
    }

    // Space to pause/resume
    if (e.key === ' ' && document.activeElement.tagName !== 'INPUT') {
        e.preventDefault();
        togglePause();
    }

    // Escape to clear search
    if (e.key === 'Escape') {
        document.getElementById('streamSearch').value = '';
        filterLogs('');
    }
});

// Pause overlay click
document.getElementById('pausedOverlay').addEventListener('click', togglePause);

// ============================================
// Transport Switching (SSH / Serial)
// ============================================
function switchTransport(transport) {
    currentTransport = transport;
    const sshSettings = document.getElementById('sshSettings');
    const serialSettings = document.getElementById('serialSettings');

    if (transport === 'ssh') {
        sshSettings.classList.remove('d-none');
        serialSettings.classList.add('d-none');
    } else {
        sshSettings.classList.add('d-none');
        serialSettings.classList.remove('d-none');
        // Auto-scan serial ports when switching to serial
        scanSerialPorts();
    }
}

// ============================================
// Serial Port Management
// ============================================
function scanSerialPorts() {
    const btn = document.getElementById('btnScan');
    const select = document.getElementById('serialPort');

    // Show loading state
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';

    fetch('/api/stream/serial/ports')
        .then(r => r.json())
        .then(data => {
            select.innerHTML = '<option value="">Select port...</option>';
            if (data.ports && data.ports.length > 0) {
                data.ports.forEach(port => {
                    const option = document.createElement('option');
                    option.value = port.device;
                    option.textContent = `${port.device} - ${port.description}`;
                    select.appendChild(option);
                });
                // Auto-select first port
                if (data.ports.length > 0) {
                    select.value = data.ports[0].device;
                }
            } else {
                select.innerHTML = '<option value="">No ports found</option>';
            }
        })
        .catch(err => {
            console.error('Failed to scan ports:', err);
            select.innerHTML = '<option value="">Error scanning ports</option>';
        })
        .finally(() => {
            btn.disabled = false;
            btn.innerHTML = '<i class="bi bi-arrow-repeat"></i>';
        });
}

function switchSerialMode() {
    const mode = document.getElementById('serialMode').value;
    const socCommandDiv = document.getElementById('socCommandDiv');
    const mcuInfoDiv = document.getElementById('mcuInfoDiv');

    if (mode === 'soc') {
        socCommandDiv.classList.remove('d-none');
        mcuInfoDiv.classList.add('d-none');
    } else {
        socCommandDiv.classList.add('d-none');
        mcuInfoDiv.classList.remove('d-none');
    }
}

function testSerialConnection() {
    const port = document.getElementById('serialPort').value;
    const baud = document.getElementById('serialBaud').value;
    const mode = document.getElementById('serialMode').value;
    const btn = document.getElementById('btnTestSerial');
    const alert = document.getElementById('connectionAlert');

    if (!port) {
        alert.classList.remove('d-none', 'alert-success');
        alert.classList.add('alert-danger');
        alert.innerHTML = '<i class="bi bi-x-circle me-2"></i>Please select a serial port first';
        return;
    }

    // Show loading state
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';

    fetch('/api/stream/serial/test', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ port, baud: parseInt(baud), mode })
    })
    .then(r => r.json())
    .then(data => {
        alert.classList.remove('d-none', 'alert-success', 'alert-danger');
        if (data.success) {
            alert.classList.add('alert-success');
            alert.innerHTML = `<i class="bi bi-check-circle me-2"></i>${data.message}`;
        } else {
            alert.classList.add('alert-danger');
            alert.innerHTML = `<i class="bi bi-x-circle me-2"></i>${data.message}`;
        }
        setTimeout(() => alert.classList.add('d-none'), 5000);
    })
    .catch(err => {
        alert.classList.remove('d-none', 'alert-success');
        alert.classList.add('alert-danger');
        alert.innerHTML = `<i class="bi bi-x-circle me-2"></i>Failed to test connection: ${err.message}`;
    })
    .finally(() => {
        btn.disabled = false;
        btn.innerHTML = '<i class="bi bi-plug"></i>';
    });
}

// ============================================
// Serial Connection
// ============================================
function connectSerial() {
    console.log('connectSerial() started');
    const portEl = document.getElementById('serialPort');
    const baudEl = document.getElementById('serialBaud');
    const modeEl = document.getElementById('serialMode');
    const commandEl = document.getElementById('serialCommand');
    const alertEl = document.getElementById('connectionAlert');

    const port = portEl ? portEl.value : '';
    const baud = baudEl ? baudEl.value : '115200';
    const mode = modeEl ? modeEl.value : 'soc';
    const command = commandEl ? commandEl.value : '';

    console.log('Serial params:', { port, baud, mode, command });

    if (!port) {
        console.log('No port selected');
        if (alertEl) {
            alertEl.classList.remove('d-none', 'alert-success');
            alertEl.classList.add('alert-danger');
            alertEl.innerHTML = '<i class="bi bi-x-circle me-2"></i>Please select a serial port first';
        }
        return;
    }

    // Hide any previous alerts
    if (alertEl) {
        alertEl.classList.add('d-none');
    }

    setStatus('connecting', 'Connecting...');

    // Build URL with parameters
    let url = `/api/stream/serial?port=${encodeURIComponent(port)}&baud=${baud}&mode=${mode}`;
    if (mode === 'soc' && command) {
        url += `&command=${encodeURIComponent(command)}`;
    }

    streamState.eventSource = new EventSource(url);
    streamState.currentCommand = mode === 'soc' ? command : 'MCU read-only';

    streamState.eventSource.onopen = function() {
        setStatus('connected', `Connected to ${port}`);
        streamState.connected = true;
        streamState.stats.startTime = Date.now();
        updateConnectButton(true);
        clearLogOutput();
    };

    streamState.commandSaved = false;

    streamState.eventSource.onmessage = function(event) {
        try {
            const data = JSON.parse(event.data);
            const alertEl = document.getElementById('connectionAlert');

            if (data.type === 'connected') {
                setStatus('connected', `${port}: ${data.mode || 'streaming'}`);
                if (alertEl) alertEl.classList.add('d-none');
            } else if (data.type === 'log') {
                if (!streamState.commandSaved && mode === 'soc' && streamState.currentCommand) {
                    saveCommandToHistory(streamState.currentCommand);
                    streamState.commandSaved = true;
                }
                addLogLine(data.content);
            } else if (data.type === 'error') {
                setStatus('error', 'Connection Error');
                if (alertEl) {
                    alertEl.classList.remove('d-none', 'alert-success');
                    alertEl.classList.add('alert-danger');
                    alertEl.innerHTML = `<i class="bi bi-x-circle me-2"></i><strong>Error:</strong> ${data.message}`;
                }
                addLogLine(`[ERROR] ${data.message}`, 'error');
                disconnect();
            } else if (data.type === 'disconnected') {
                setStatus('disconnected', 'Disconnected');
                streamState.connected = false;
                updateConnectButton(false);
            }
        } catch (e) {
            console.error('Parse error:', e);
        }
    };

    streamState.eventSource.onerror = function(e) {
        setStatus('error', 'Connection failed');
        streamState.connected = false;
        updateConnectButton(false);

        const alertEl = document.getElementById('connectionAlert');
        if (alertEl) {
            alertEl.classList.remove('d-none', 'alert-success');
            alertEl.classList.add('alert-danger');
            alertEl.innerHTML = `<i class="bi bi-x-circle me-2"></i><strong>Serial connection failed</strong><br>
                <small>Check that the serial port is not in use by another application.</small>`;
        }
    };
}

// Init
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing...');

    // Auto-scroll button starts active
    document.getElementById('btnAutoscroll').classList.add('active');

    // Load command history
    renderCommandHistory();

    // Add click handler for connect button (backup for onclick)
    const btnConnect = document.getElementById('btnConnect');
    if (btnConnect) {
        console.log('Connect button found, adding click listener');
        btnConnect.addEventListener('click', function(e) {
            e.preventDefault();
            console.log('Connect button clicked via addEventListener');
            toggleConnection();
        });
    } else {
        console.error('Connect button not found!');
    }
});
</script>
{% endblock %}
